<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>盈盈的博客</title>
  
  <subtitle>我是盈盈，但没有令狐冲；我不是圣姑，我只是代码搬运工</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.zhaiyingying.cn/"/>
  <updated>2018-08-02T11:45:51.194Z</updated>
  <id>http://blog.zhaiyingying.cn/</id>
  
  <author>
    <name>zhai yingying</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>30分钟掌握ES6/ES2015核心内容（下）</title>
    <link href="http://blog.zhaiyingying.cn/2017/10/28/20171028-2/"/>
    <id>http://blog.zhaiyingying.cn/2017/10/28/20171028-2/</id>
    <published>2017-10-28T04:40:04.000Z</published>
    <updated>2018-08-02T11:45:51.194Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="http://segmentfault.com/a/1190000004365693" target="_blank" rel="noopener">30分钟掌握ES6/ES2015核心内容（上）</a>我们讲解了es6最常用的一些语法：<code>let, const, class, extends, super, arrow functions, template string, destructuring, default, rest arguments</code></p><p>俗话说打铁要趁热，今天我们继续讲es6其他几个非常有用的新特性。</p><h2 id="import-export"><a href="#import-export" class="headerlink" title="import export"></a>import export</h2><p>这两个家伙对应的就是es6自己的<code>module</code>功能。</p><p>我们之前写的Javascript一直都没有模块化的体系，无法将一个庞大的js工程拆分成一个个功能相对独立但相互依赖的小工程，再用一种简单的方法把这些小工程连接在一起。</p><p>这有可能导致两个问题：</p><ol><li>一方面js代码变得很臃肿，难以维护</li><li>另一方面我们常常得很注意每个script标签在html中的位置，因为它们通常有依赖关系，顺序错了可能就会出bug</li></ol><p>在es6之前为解决上面提到的问题，我们得利用第三方提供的一些方案，主要有两种CommonJS(服务器端)和AMD（浏览器端，如require.js）。</p><p>如果想了解更多AMD，尤其是require.js，可以参看这个教程：<a href="http://requirejs.org/docs/why.html" target="_blank" rel="noopener">why modules on the web are useful and the mechanisms that can be used on the web today to enable them</a></p><p>而现在我们有了es6的module功能，它实现非常简单，可以成为服务器和浏览器通用的模块解决方案。</p><blockquote><p>ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。</p></blockquote><p>上面的设计思想看不懂也没关系，咱先学会怎么用，等以后用多了、熟练了再去研究它背后的设计思想也不迟！好，那我们就上代码…</p><p>传统的写法</p><p>首先我们回顾下require.js的写法。假设我们有两个js文件: <code>index.js</code>和<code>content.js</code>,现在我们想要在<code>index.js</code>中使用<code>content.js</code>返回的结果，我们要怎么做呢？</p><p>首先定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//content.js</span><br><span class="line">define(&apos;content.js&apos;, function()&#123;</span><br><span class="line">    return &apos;A cat&apos;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后require：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">require([&apos;./content.js&apos;], function(animal)&#123;</span><br><span class="line">    console.log(animal);   //A cat</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那CommonJS是怎么写的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">var animal = require(&apos;./content.js&apos;)</span><br><span class="line"></span><br><span class="line">//content.js</span><br><span class="line">module.exports = &apos;A cat&apos;</span><br></pre></td></tr></table></figure><p>ES6的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">import animal from &apos;./content&apos;</span><br><span class="line"></span><br><span class="line">//content.js</span><br><span class="line">export default &apos;A cat&apos;</span><br></pre></td></tr></table></figure><p>以上我把三者都列出来了，妈妈再也不用担心我写混淆了…</p><h2 id="ES6-module的其他高级用法"><a href="#ES6-module的其他高级用法" class="headerlink" title="ES6 module的其他高级用法"></a>ES6 module的其他高级用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//content.js</span><br><span class="line"></span><br><span class="line">export default &apos;A cat&apos;</span><br><span class="line">export function say()&#123;</span><br><span class="line">    return &apos;Hello!&apos;</span><br><span class="line">&#125;</span><br><span class="line">export const type = &apos;dog&apos;</span><br></pre></td></tr></table></figure><p>上面可以看出，export命令除了输出变量，还可以输出函数，甚至是类（react的模块基本都是输出类）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line"></span><br><span class="line">import &#123; say, type &#125; from &apos;./content&apos;</span><br><span class="line">let says = say()</span><br><span class="line">console.log(`The $&#123;type&#125; says $&#123;says&#125;`)  //The dog says Hello</span><br></pre></td></tr></table></figure><p>这里输入的时候要注意：大括号里面的变量名，必须与被导入模块（content.js）对外接口的名称相同。</p><p>如果还希望输入content.js中输出的默认值(default), 可以写在大括号外面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line"></span><br><span class="line">import animal, &#123; say, type &#125; from &apos;./content&apos;</span><br><span class="line">let says = say()</span><br><span class="line">console.log(`The $&#123;type&#125; says $&#123;says&#125; to $&#123;animal&#125;`)</span><br><span class="line">//The dog says Hello to A cat</span><br></pre></td></tr></table></figure><p>修改变量名</p><p>此时我们不喜欢type这个变量名，因为它有可能重名，所以我们需要修改一下它的变量名。在es6中可以用<code>as</code>实现一键换名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line"></span><br><span class="line">import animal, &#123; say, type as animalType &#125; from &apos;./content&apos;</span><br><span class="line">let says = say()</span><br><span class="line">console.log(`The $&#123;animalType&#125; says $&#123;says&#125; to $&#123;animal&#125;`)</span><br><span class="line">//The dog says Hello to A cat</span><br></pre></td></tr></table></figure><p>模块的整体加载</p><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（<code>*</code>）指定一个对象，所有输出值都加载在这个对象上面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line"></span><br><span class="line">import animal, * as content from &apos;./content&apos;</span><br><span class="line">let says = content.say()</span><br><span class="line">console.log(`The $&#123;content.type&#125; says $&#123;says&#125; to $&#123;animal&#125;`)</span><br><span class="line">//The dog says Hello to A cat</span><br></pre></td></tr></table></figure><p>通常星号<code>*</code>结合<code>as</code>一起使用比较合适。</p><h2 id="终极秘籍"><a href="#终极秘籍" class="headerlink" title="终极秘籍"></a>终极秘籍</h2><p>考虑下面的场景：上面的<code>content.js</code>一共输出了三个变量（<code>default, say, type</code>）,假如我们的实际项目当中只需要用到<code>type</code>这一个变量，其余两个我们暂时不需要。我们可以只输入一个变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; type &#125; from &apos;./content&apos;</span><br></pre></td></tr></table></figure><p>由于其他两个变量没有被使用，我们希望代码打包的时候也忽略它们，抛弃它们，这样在大项目中可以显著减少文件的体积。</p><p>ES6帮我们实现了！</p><p>不过，目前无论是webpack还是browserify都还不支持这一功能…</p><p>如果你现在就想实现这一功能的话，可以尝试使用<a href="http://rollupjs.org/" target="_blank" rel="noopener">rollup.js</a></p><p>他们把这个功能叫做Tree-shaking，哈哈哈，意思就是打包前让整个文档树抖一抖，把那些并未被依赖或使用的东西统统抖落下去。。。</p><p>看看他们官方的解释吧：</p><blockquote><p>Normally if you require a module, you import the whole thing. ES2015 lets you just import the bits you need, without mucking around with custom builds. It’s a revolution in how we use libraries in JavaScript, and it’s happening right now.</p></blockquote>]]></content>
    
    <summary type="html">
    
      ES6/ES2015核心内容
    
    </summary>
    
      <category term="技术转载" scheme="http://blog.zhaiyingying.cn/categories/%E6%8A%80%E6%9C%AF%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="javascript" scheme="http://blog.zhaiyingying.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>30分钟掌握ES6/ES2015核心内容（上）</title>
    <link href="http://blog.zhaiyingying.cn/2017/10/28/20171028-1/"/>
    <id>http://blog.zhaiyingying.cn/2017/10/28/20171028-1/</id>
    <published>2017-10-28T04:39:04.000Z</published>
    <updated>2018-08-02T11:45:51.204Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。</p><p>也就是说，ES6就是ES2015。</p><p>虽然目前并不是所有浏览器都能兼容ES6全部特性，但越来越多的程序员在实际项目当中已经开始使用ES6了。所以就算你现在不打算使用ES6，但为了看懂别人的你也该懂点ES6的语法了…</p><p>在我们正式讲解ES6语法之前，我们得先了解下Babel。<br><a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a></p><p>Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。大家可以选择自己习惯的工具来使用使用Babel，具体过程可直接在Babel官网查看：<br><img src="/images/20171028-1-1.png" alt=""></p><h2 id="最常用的ES6特性"><a href="#最常用的ES6特性" class="headerlink" title="最常用的ES6特性"></a>最常用的ES6特性</h2><p><code>let, const, class, extends, super, arrow functions, template string, destructuring, default, rest arguments</code><br>这些是ES6最常用的几个语法，基本上学会它们，我们就可以走遍天下都不怕啦！我会用最通俗易懂的语言和例子来讲解它们，保证一看就懂，一学就会。</p><h2 id="let-const"><a href="#let-const" class="headerlink" title="let, const"></a>let, const</h2><p>这两个的用途与<code>var</code>类似，都是用来声明变量的，但在实际运用中他俩都有各自的特殊用途。<br>首先来看下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;zach&apos;</span><br><span class="line"></span><br><span class="line">while (true) &#123;</span><br><span class="line">    var name = &apos;obama&apos;</span><br><span class="line">    console.log(name)  //obama</span><br><span class="line">    break</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(name)  //obama</span><br></pre></td></tr></table></figure><p>使用<code>var</code>两次输出都是obama，这是因为ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景就是你现在看到的内层变量覆盖外层变量。而<code>let</code>则实际上为JavaScript新增了块级作用域。用它所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let name = &apos;zach&apos;</span><br><span class="line"></span><br><span class="line">while (true) &#123;</span><br><span class="line">    let name = &apos;obama&apos;</span><br><span class="line">    console.log(name)  //obama</span><br><span class="line">    break</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(name)  //zach</span><br></pre></td></tr></table></figure><p>另外一个<code>var</code>带来的不合理场景就是用来计数的循环变量泄露为全局变量，看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 10</span><br></pre></td></tr></table></figure><p>上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。而使用let则不会出现这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 6</span><br></pre></td></tr></table></figure><p>再来看一个更常见的例子，了解下如果不用ES6，而用闭包如何解决这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var clickBoxs = document.querySelectorAll(&apos;.clickBox&apos;)</span><br><span class="line">for (var i = 0; i &lt; clickBoxs.length; i++)&#123;</span><br><span class="line">    clickBoxs[i].onclick = function()&#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们本来希望的是点击不同的clickBox，显示不同的i，但事实是无论我们点击哪个clickBox，输出的都是5。下面我们来看下，如何用闭包搞定它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function iteratorFactory(i)&#123;</span><br><span class="line">    var onclick = function(e)&#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">    return onclick;</span><br><span class="line">&#125;</span><br><span class="line">var clickBoxs = document.querySelectorAll(&apos;.clickBox&apos;)</span><br><span class="line">for (var i = 0; i &lt; clickBoxs.length; i++)&#123;</span><br><span class="line">    clickBoxs[i].onclick = iteratorFactory(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>const</code>也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const PI = Math.PI</span><br><span class="line"></span><br><span class="line">PI = 23 //Module build failed: SyntaxError: /es6/app.js: &quot;PI&quot; is read-only</span><br></pre></td></tr></table></figure><p>当我们尝试去改变用const声明的常量时，浏览器就会报错。const有一个很好的应用场景，就是当我们引用第三方库的时声明的变量，用const来声明可以避免未来不小心重命名而导致出现bug：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const monent = require(&apos;moment&apos;)</span><br></pre></td></tr></table></figure><h2 id="class-extends-super"><a href="#class-extends-super" class="headerlink" title="class, extends, super"></a>class, extends, super</h2><p>这三个特性涉及了ES5中最令人头疼的的几个部分：原型、构造函数，继承…你还在为它们复杂难懂的语法而烦恼吗？你还在为指针到底指向哪里而纠结万分吗？</p><p>有了ES6我们不再烦恼！</p><p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.type = &apos;animal&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    says(say)&#123;</span><br><span class="line">        console.log(this.type + &apos; says &apos; + say)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let animal = new Animal()</span><br><span class="line">animal.says(&apos;hello&apos;) //animal says hello</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super()</span><br><span class="line">        this.type = &apos;cat&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cat = new Cat()</span><br><span class="line">cat.says(&apos;hello&apos;) //cat says hello</span><br></pre></td></tr></table></figure><p>上面代码首先用<code>class</code>定义了一个“类”，可以看到里面有一个<code>constructor</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象。简单地说，<code>constructor</code>内定义的方法和属性是实例对象自己的，而<code>constructor</code>外定义的方法和属性则是所有实例对象可以共享的。</p><p>Class之间可以通过<code>extends</code>关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个Cat类，该类通过<code>extends</code>关键字，继承了Animal类的所有属性和方法。</p><p><code>super</code>关键字，它指代父类的实例（即父类的this对象）。子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类没有自己的<code>this</code>对象，而是继承父类的<code>this</code>对象，然后对其进行加工。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p><p>ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p><p>P.S 如果你写react的话，就会发现以上三个东西在最新版React中出现得很多。创建的每个component都是一个继承<code>React.Component</code>的类。<a href="https://facebook.github.io/react/docs/reusable-components.html" target="_blank" rel="noopener">详见react文档</a></p><h2 id="arrow-function"><a href="#arrow-function" class="headerlink" title="arrow function"></a>arrow function</h2><p>这个恐怕是ES6最最常用的一个新特性了，用它来写function比原来的写法要简洁清晰很多:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function(i)&#123; return i + 1; &#125; //ES5</span><br><span class="line">(i) =&gt; i + 1 //ES6</span><br></pre></td></tr></table></figure><p>简直是简单的不像话对吧…<br>如果方程比较复杂，则需要用<code>{}</code>把代码包起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function(x, y) &#123;</span><br><span class="line">    x++;</span><br><span class="line">    y--;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">(x, y) =&gt; &#123;x++; y--; return x+y&#125;</span><br></pre></td></tr></table></figure><p>除了看上去更简洁以外，arrow function还有一项超级无敌的功能！<br>长期以来，JavaScript语言的<code>this</code>对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.type = &apos;animal&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    says(say)&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(this.type + &apos; says &apos; + say)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> var animal = new Animal()</span><br><span class="line"> animal.says(&apos;hi&apos;)  //undefined says hi</span><br></pre></td></tr></table></figure><p>运行上面的代码会报错，这是因为<code>setTimeout</code>中的<code>this</code>指向的是全局对象。所以为了让它能够正确的运行，传统的解决方法有两种：</p><ol><li>第一种是将this传给self,再用self来指代this</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">says(say)&#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(self.type + &apos; says &apos; + say)</span><br><span class="line">    &#125;, 1000)</span><br></pre></td></tr></table></figure><p>  2.第二种方法是用<code>bind(this)</code>,即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">says(say)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(this.type + &apos; says &apos; + say)</span><br><span class="line">    &#125;.bind(this), 1000)</span><br></pre></td></tr></table></figure><p>  但现在我们有了箭头函数，就不需要这么麻烦了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.type = &apos;animal&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    says(say)&#123;</span><br><span class="line">        setTimeout( () =\&gt; &#123;</span><br><span class="line">            console.log(this.type + &apos; says &apos; + say)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> var animal = new Animal()</span><br><span class="line"> animal.says(&apos;hi&apos;)  //animal says hi</span><br></pre></td></tr></table></figure><p>当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。</p><h2 id="template-string"><a href="#template-string" class="headerlink" title="template string"></a>template string</h2><p>这个东西也是非常有用，当我们要插入大段的html内容到文档中时，传统的写法非常麻烦，所以之前我们通常会引用一些模板工具库，比如mustache等等。</p><p>大家可以先看下面一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;\#result&quot;).append(</span><br><span class="line">  &quot;There are \&lt;b\&gt;&quot; + basket.count + &quot;\&lt;/b\&gt; &quot; +</span><br><span class="line">  &quot;items in your basket, &quot; +</span><br><span class="line">  &quot;\&lt;em\&gt;&quot; + basket.onSale +</span><br><span class="line">  &quot;\&lt;/em\&gt; are on sale!&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们要用一堆的’+’号来连接文本与变量，而使用ES6的新特性模板字符串<code></code>后，我们可以直接这么来写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;\#result&quot;).append(` There are \&lt;b\&gt;$&#123;basket.count&#125;\&lt;/b\&gt; items in your basket, \&lt;em\&gt;$&#123;basket.onSale&#125;\&lt;/em\&gt; are on sale! `);</span><br></pre></td></tr></table></figure><p>用反引号<code>（\</code>）<code>来标识起始，用</code>${}`来引用变量，而且所有的空格和缩进都会被保留在输出之中，是不是非常爽？！</p><p>React Router从第1.0.3版开始也使用ES6语法了，比如这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\&lt;Link to=&#123;`/taco/$&#123;taco.name&#125;`&#125;\&gt;&#123;taco.name&#125;\&lt;/Link\&gt;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/rackt/react-router/blob/latest/examples/passing-props-to-children/app.js" target="_blank" rel="noopener">React Router</a></p><h2 id="destructuring"><a href="#destructuring" class="headerlink" title="destructuring"></a>destructuring</h2><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><p>看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let cat = &apos;ken&apos;</span><br><span class="line">let dog = &apos;lili&apos;</span><br><span class="line">let zoo = &#123;cat: cat, dog: dog&#125;</span><br><span class="line">console.log(zoo)  //Object &#123;cat: &quot;ken&quot;, dog: &quot;lili&quot;&#125;</span><br></pre></td></tr></table></figure><p>用ES6完全可以像下面这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let cat = &apos;ken&apos;</span><br><span class="line">let dog = &apos;lili&apos;</span><br><span class="line">let zoo = &#123;cat, dog&#125;</span><br><span class="line">console.log(zoo)  //Object &#123;cat: &quot;ken&quot;, dog: &quot;lili&quot;&#125;</span><br></pre></td></tr></table></figure><p>反过来可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let dog = &#123;type: &apos;animal&apos;, many: 2&#125;</span><br><span class="line">let &#123; type, many&#125; = dog</span><br><span class="line">console.log(type, many)   //animal 2</span><br></pre></td></tr></table></figure><h2 id="default-rest"><a href="#default-rest" class="headerlink" title="default, rest"></a>default, rest</h2><p>default很简单，意思就是默认值。大家可以看下面的例子，调用<code>animal()</code>方法时忘了传参数，传统的做法就是加上这一句<code>type = type || &#39;cat&#39;</code>来指定默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function animal(type)&#123;</span><br><span class="line">    type = type || &apos;cat&apos;</span><br><span class="line">    console.log(type)</span><br><span class="line">&#125;</span><br><span class="line">animal()</span><br></pre></td></tr></table></figure><p>如果用ES6我们而已直接这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function animal(type = &apos;cat&apos;)&#123;</span><br><span class="line">    console.log(type)</span><br><span class="line">&#125;</span><br><span class="line">animal()</span><br></pre></td></tr></table></figure><p>最后一个rest语法也很简单，直接看例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function animals(...types)&#123;</span><br><span class="line">    console.log(types)</span><br><span class="line">&#125;</span><br><span class="line">animals(&apos;cat&apos;, &apos;dog&apos;, &apos;fish&apos;) //[&quot;cat&quot;, &quot;dog&quot;, &quot;fish&quot;]</span><br></pre></td></tr></table></figure><p>而如果不用ES6的话，我们则得使用ES5的<code>arguments</code>。</p>]]></content>
    
    <summary type="html">
    
      ES6/ES2015核心内容
    
    </summary>
    
      <category term="技术转载" scheme="http://blog.zhaiyingying.cn/categories/%E6%8A%80%E6%9C%AF%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="javascript" scheme="http://blog.zhaiyingying.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://blog.zhaiyingying.cn/2016/05/01/hello-world/"/>
    <id>http://blog.zhaiyingying.cn/2016/05/01/hello-world/</id>
    <published>2016-05-01T02:09:00.000Z</published>
    <updated>2018-08-02T11:45:51.200Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      hexo 基本语法
    
    </summary>
    
      <category term="技术转载" scheme="http://blog.zhaiyingying.cn/categories/%E6%8A%80%E6%9C%AF%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="工具" scheme="http://blog.zhaiyingying.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
